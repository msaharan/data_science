metadata:
  createdAt: 2025-12-12T21:30:05.176Z
project:
  id: 3c53603c-673c-4736-a028-7c62f4af9269
  integrations: []
  name: scheduling_optimization_scipy
  notebooks:
    - blocks:
        - blockGroup: 644191d1-b08b-4459-825b-6207f16d88a7
          content: "# Exercise — Scheduling Optimisation"
          id: 30d9719f-0dbb-4669-a332-468748baca95
          metadata: {}
          sortingKey: "0"
          type: markdown
        - blockGroup: c023b746-c2b0-4447-b32f-53d9204b4312
          content: "## Scenario"
          id: a279f3a7-bc5c-450f-a69f-e6ffff9794f3
          metadata: {}
          sortingKey: "1"
          type: markdown
        - blockGroup: b6c5507e-daa3-47e3-a3bf-fb9913edf34a
          content: |+
            You must assign 5 tasks to 5 engineers.
            Each engineer has a task-specific “cost” (lower is better).
            You must assign exactly 1 task per engineer.

            ### Input

            ```python
            cost_matrix = np.array([
                [9, 2, 7, 8, 6],
                [6, 4, 3, 7, 5],
                [5, 8, 1, 8, 7],
                [7, 6, 9, 4, 3],
                [8, 5, 6, 9, 4]
            ])
            ```
            Rows: engineers
            Columns: tasks

            ### Task

            Write:

            ```python
            def assign_tasks(cost_matrix: np.ndarray):
                ...
            ```

            ### Requirements

            - Use scipy.optimize.linear_sum_assignment.
            - Return a dictionary:
            ```python
            {
                "assignments": [(engineer_idx, task_idx), ...],
                "total_cost": float
            }
            ```

            ### Evaluation Criteria
            - Correct use of the algorithm
            - Type hints
            - Nicely formatted output
            - No unnessary loops

          id: 08f7ba04-6ca3-4171-a37f-9f1e05fc9474
          metadata: {}
          sortingKey: "2"
          type: markdown
        - blockGroup: 5ed404c7-7119-4730-9fc3-64308badf47e
          content: ""
          id: c1aabf4d-2561-450f-8eb3-66a28aa929e8
          metadata: {}
          sortingKey: "3"
          type: markdown
        - blockGroup: 95dc27e2-7230-4aa5-ba7d-db540135accf
          content: "## Thinking through the problem"
          id: a8cd3860-050c-496d-a5b7-4c66835d60fb
          metadata: {}
          sortingKey: "4"
          type: markdown
        - blockGroup: 1489979d-1b78-47f2-9f0b-69d96ca6f5d4
          content: "### 1. What is the problem, in plain terms?"
          id: a66c5e80-be18-4c5b-8adc-a90ce4d39623
          metadata: {}
          sortingKey: "5"
          type: markdown
        - blockGroup: 0dd97945-a61c-4bb4-88f2-01c5289a8ced
          content: >+
            We have:

            - `n_engineers`

            - `n_tasks`

            - `cost_matrix[i, j]` = cost if engineer `i` is assigned to task `j`


            We want to assign each engineer to exactly one task (and each task
            to at most one engineer) such that the total cost is minimized.


            The function must return:


            ```python

            {
                "assignments": [(engineer_idx, task_idx), ...],
                "total_cost": float
            }

            ```

            Where:

            - `engineer_idx` and `task_idx` are 0-based indices (consistent with
            numpy).

            - `total_cost` is the sum of `cost_matrix[i, j]` for all chosen
            pairs.

          id: 6bfb0590-fc75-42a5-b59f-7a57b099e3c9
          metadata: {}
          sortingKey: "6"
          type: markdown
        - blockGroup: 734e03bd-24da-43f3-89bc-386041f89586
          content: "### 2. Shape and assumptions"
          id: a2fed30a-2292-4dd5-87a6-edb7d562e2dc
          metadata: {}
          sortingKey: "7"
          type: markdown
        - blockGroup: aaa7e052-246c-46f3-9da5-d645a33bcbd0
          content: >-
            `cost_matrix` is a 2D numpy array of shape:

            ```python

            (n_engineers, n_tasks)

            ```


            Some quick considerations:

            - Typical assignment problenms are square: same number of workers
            and tasks.

            - `scipy.optimize.linear_sum_assignment` can handle rectangular
            matrices.
                - If there are more tasks than engineers, we will assign each engineer to exactly one task, and some tasks remain unassigned.
                - If there are more engineers than tasks, some engineers remain unassigned.

            <!-- The problem statement is a bit vague about this, but since they
            just say “cost matrix (n_engineers, n_tasks)” and don’t complain
            about rectangular, we can just trust linear_sum_assignment to behave
            sensibly. -->
          id: cb9f6bfe-e7ee-46fc-b87a-a7835822dda4
          metadata: {}
          sortingKey: "8"
          type: markdown
        - blockGroup: f00b6962-d7d4-498b-b875-d40d30c74724
          content: |+
            ### 3. Using `linear_sum_assignment`





          id: 12eae0cb-47d1-4943-9c3b-b94d44db5250
          metadata: {}
          sortingKey: "9"
          type: markdown
        - blockGroup: ff4ba433-484c-417c-b7cc-689d418206fd
          content: >+
            `linear_sum_assignment(cost_matrix)` returns two arrays:

            ```python

            row_ind, col_ind = linear_sum_assignment(cost_matrix)

            ```


            - `row_ind[k]` = index of an engineer

            -  `col_ind[k]` = index of the task that engineer is assigned to


            These indices are aligned, i.e.:

            - Assignment `k` is `row_ind[k], col_ind[k]`


            So, the list of pairs we want is:

            ```python

            cost_matrix_demo = np.array([
                [9, 2, 7, 8, 6],
                [6, 4, 3, 7, 5],
                [5, 8, 1, 8, 7],
                [7, 6, 9, 4, 3],
                [8, 5, 6, 9, 4]
            ])

            ```

            You will get some `row_ind` and `col_ind` arrays, and each
            (row_ind[i], col_ind[i]) is an (engineer_idx, task_idx)` pair.




          id: 626e516e-e1ed-4c8f-bfa3-f40425484a51
          metadata: {}
          sortingKey: a
          type: markdown
        - blockGroup: 32c6dfda-f97d-4fe6-93d4-e57f6922459b
          content: "### 4. Computing the total cost"
          id: 3612cec5-9c4f-4e29-afa6-b97ff71d348e
          metadata: {}
          sortingKey: b
          type: markdown
        - blockGroup: c73ad3ae-3b3c-4b6b-8cfc-b28b8cef8b22
          content: >-
            Once we have the assignments, we compute:

            $$

            \text{total\_cost} = \sum_k \text{cost\_matrix}[row\_ind[k],
            col\_ind[k]]

            $$

            In NumPy terms:

            - we can loop:

            ```python

            total_cost = 0.0

            for i, j in assignments:
                total_cost += cost_matrix[i, j]
            ```

            - Or we can be fancy and use advanced indexing:

            ```python

            total_cost = float(cost_matrix[row_ind, col_ind].sum())

            ```
          id: 441cc7e3-c5c7-4a9b-b464-b261d41d25a1
          metadata: {}
          sortingKey: c
          type: markdown
        - blockGroup: 844dfe1c-b95d-41e0-bd24-cb1f2016b563
          content: "### 5. Edge cases / sanity checks"
          id: 543914c4-a214-4da1-96a3-f8198a7b98a5
          metadata: {}
          sortingKey: d
          type: markdown
        - blockGroup: cfa671f4-3369-4841-ab4d-4d00c601b788
          content: >-
            Conceptually:

            - `cost_matrix` should be numeric and 2D.

            - We don't typically get infeasibility here; the algorithm always
            gives a minimal assignment for the given matrix.

            - Negative costs are allowed by `linear_sum_assignent`, but usually
            cost matrices are non-negative. 


            Sanity checks after implementation:

            - Number of assignments equals `min(n_engineers, n_tasks)` (for
            rectangular).

            - Each engineer index appears at most once.

            - Each task index appears at most once.

            - `total_cost` equals sum of `cost_matrix[i, j]` for each pair in
            `assignments`.
          id: 3c06c715-d70e-45d6-8c40-913cb389a788
          metadata: {}
          sortingKey: e
          type: markdown
        - blockGroup: dc51f85c-2ba4-4296-b5b1-7c2d587b6518
          content: "## Code implementation"
          id: 2d05003c-37b1-4514-a45f-016f9bf30a41
          metadata: {}
          sortingKey: f
          type: markdown
        - blockGroup: 5c082aa5-732b-4378-a350-92b17c0ebde0
          content: >-
            import math 

            from typing import Dict, Any, List, Tuple 

            import numpy as np 

            import pandas as pd 

            from scipy.optimize import linear_sum_assignment


            def assign_tasks(cost_matrix: np.ndarray) -> Dict[str, Any]:
                """
                Assign tasks to engineers to minimize total cost using the assignment problem.
                
                This function solves a classic assignment problem: given N engineers and N tasks,
                find the one-to-one assignment that minimizes total cost. This is a fundamental
                optimization problem in operations research, useful for resource allocation,
                scheduling, and matching problems.
                
                The Hungarian algorithm (via linear_sum_assignment) efficiently solves this
                in polynomial time, making it practical for real-world applications.

                Args:
                    cost_matrix: 2D numpy array of shape (n_engineers, n_tasks)
                                cost_matrix[i, j] is the cost of assigning engineer i to task j.
                                Lower values are better (we're minimizing total cost).
                                
                Returns:
                    {
                        "assignments": [(engineer_idx, task_idx), ...],
                        "total_cost": float
                    }
                    Each tuple (i, j) in assignments means engineer i is assigned to task j.
                    total_cost is the sum of cost_matrix[i, j] for all assignment pairs.
                """
                # STEP 1: Solve the assignment problem using the Hungarian algorithm
                # linear_sum_assignment finds the optimal one-to-one matching that minimizes
                # the sum of costs. It returns two aligned arrays:
                #   - row_ind: engineer indices in the optimal assignment
                #   - col_ind: task indices assigned to those engineers
                # The arrays are aligned: engineer row_ind[k] is assigned to task col_ind[k]
                # 
                # Why Hungarian algorithm? It's efficient (O(n³)) and guarantees optimality
                # for this type of problem, unlike greedy approaches which might miss better solutions
                row_ind, col_ind = linear_sum_assignment(cost_matrix)

                # STEP 2: Format assignments as list of (engineer_idx, task_idx) tuples
                # Convert the aligned arrays into a readable list of pairs
                # This format is more intuitive than separate arrays and easier to iterate over
                # Example: row_ind=[0,1,2], col_ind=[1,0,2] → [(0,1), (1,0), (2,2)]
                #          means engineer 0→task 1, engineer 1→task 0, engineer 2→task 2
                assignments: List[Tuple[int, int]] = list(zip(row_ind.tolist(), col_ind.tolist()))  

                # STEP 3: Compute total cost of the optimal assignment
                # Use NumPy advanced indexing: cost_matrix[row_ind, col_ind] extracts the cost
                # for each assignment pair, creating an array of individual costs
                # Then sum() adds them up to get the total cost
                # This is more efficient than looping: cost_matrix[row_ind, col_ind].sum()
                # Example: If assignments are [(0,1), (1,0), (2,2)], we compute:
                #          cost_matrix[0,1] + cost_matrix[1,0] + cost_matrix[2,2]
                total_cost = float(cost_matrix[row_ind, col_ind].sum())

                # STEP 4: Return structured result
                # Dictionary format provides clear, self-documenting output that's easy to
                # serialize (JSON), display in UIs, or use in downstream processing
                return {
                    "assignments": assignments,  # List of (engineer_idx, task_idx) pairs
                    "total_cost": total_cost  # Sum of costs for optimal assignment
                }

            # if __name__ == "__main__":


            cost_matrix_demo = np.array([
                [9, 2, 7, 8, 6],
                [6, 4, 3, 7, 5],
                [5, 8, 1, 8, 7],
                [7, 6, 9, 4, 3],
                [8, 5, 6, 9, 4],
            ])


            result3 = assign_tasks(cost_matrix_demo)

            print("Exercise result:", result3)


            ## sanity check

            # Assignments:


            # Engineer 0 → Task 1 → cost = 2


            # Engineer 1 → Task 0 → cost = 6


            # Engineer 2 → Task 2 → cost = 1


            # Engineer 3 → Task 3 → cost = 4


            # Engineer 4 → Task 4 → cost = 4


            # Total cost = 2 + 6 + 1 + 4 + 4 = 17.
          id: a0e39c45-fe0b-445e-bbd0-60d98a83dbc5
          metadata: {}
          outputs:
            - name: stdout
              output_type: stream
              text:
                - >
                  Exercise result: {'assignments': [(0, 1), (1, 0), (2, 2), (3,
                  3), (4, 4)], 'total_cost': 17.0}
          sortingKey: g
          type: code
      executionMode: block
      id: 1c5fb9be-8007-4565-bf57-2307a0c05047
      isModule: false
      name: scheduling_optimization_scipy
  settings: {}
version: 1.0.0
